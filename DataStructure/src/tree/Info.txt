对Tree结构的学习

1.在Order.java中对递归实现前、中、后序遍历进行学习
  1) 首先如何构建起一颗二叉树是关键问题，如何做到有序插入?
       -> 这里使用循环实现，当然也可以使用递归的方法
  2) 使用递归调用的方式，仅需改变结点输出与递归调用本函数的位置即可实现前、中、后序遍历

2.关于实现二叉树的查找问题 -> 在前、中、后序遍历的基础之上稍作修改即可
  1) 在Order.java中对前序查找方式进行实现
  2) 倘若要求将该结点作为返回值进行返回,如何处理return问题 -> (尝试在根节点上加以判断)
    -> 如何使用递归的方式进行实现?   --> 拆分两个函数，第二个进行递归
    -> 当然，也可以使用非递归方式进行   --> while()

附:① 递归+双函数 -> [1] 根据根节点的值和需要查询的值作比较，划分为三种情况
                   [2] 在左右两个子树查询的时候，需要使用递归调用函数(第二个函数)
                   [3] 在编写递归函数的时候可以参考前序遍历递归方式
   ② while()   -> [1] 仍将方法由根节点划分为三部分
                   [2] 某种程度上来说，在左右两个子树中查找的方式类似于镜像模式
   ③ 经数据测试,暂未发现第一种方法的漏洞,第二种有问题!!!!!

3.老师对于查找的实现方式真的是一绝!!!
   -> 使用TreeNode temp 接收从左子树查询的结果!!!
   -> 若不为空则返回,若为空则继续在右子树中进行查找
   -> 返回右子树查询结果!


4.二叉树删除结点
  这里尝试着实现简化的删除方法


5.顺序存储二叉树的实现
  -> 将二叉树存储在数组之中，按照顺序遍历的方式进行存储
  -> 如何实现顺序存储二叉树的前、中、后序遍历   ???
    -> 使用堆栈?
    -> 使用递归?
  在ArrayTree.java中对以上内容进行学习     ->      使用递归实现顺序存储二叉树的三种遍历方式
附:在Order.java中实现层次遍历
   JVM自带的Queue实在太难用了，直接实现链队列    ->使用手写队列成功实现!


6.实现二叉树的线索化 -> 以中序线索化二叉树为例      -> 在ThreadBinaryTree.java中实现
  1) 设置两个标识符，标识是否指向左子树或者右子树 boolean
  2) 设置一个辅助指针，永远指向该结点的前序结点4
  3) 首先处理以该结点为根的左子树，接下来处理当前结点，最后处理右子树
附:① 在Order.java中实现的二叉树的建立是典中典!!!                                  ※
   ② 实现思路是依靠和中序遍历类似的方式构建线索,在实现线索化之前要对所有结点的标识位进行赋值!
      -> 这里直接使用层次遍历实现
   ③ 到达此节点时，若该结点的左指针没有指向，则令其指向前驱结点，
      若其前驱结点不为空，且前驱结点右指针为空，令其前驱结点的右指针指向该结点!     ->  冗杂至极!
      ※:直接判断前驱结点的右指针是否为空(当然要判断是否无前序结点),设置其右指针即可

7.线索化二叉树的遍历方式
  1) 寻找第一个结点
  2) 进入循环，直到最后一个结点      存在问题! -> 下一个结点不一定是其右子结点!
  3) 解决：使用循环 while(node.getLchild() != null && node.isIslchild()) 判断下一个结点的位置


8.在HeapSortTest中实现堆排序
  基本思路:
  1) 将待排序的数组构造成一个大根堆
  2) 此时整个序列最大值就是堆顶的根节点
  3) 将其与末尾元素进行交换，此时末尾的值就是最大值
  4) 然后将剩余n-1个元素重新构造成一个堆，这样就会得到n个元素的次小值。反复以上步骤
附:堆排序还是等到以后复习的时候看看老鲍的视频

9.经过近一上午的嗯理解，终于将大致思路进行理解
  详细内容查看AnalysisHeapSortTest.java中对堆排序的进一步分析    -> 老鲍牛批!!!


10.构建HuffmanTree的过程分析   ->  HuffmanTreeTest.java
   1) 将所有的数据从小到大进行排列，每一个数据都可以作为一个结点，每一个节点都可以看做一颗最简单的二叉树
   2) 取出根节点权值最小的两颗二叉树
   3) 组成一颗新的二叉树，该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和
   4) 再将这颗新的二叉树，以根节点的权值大小再次排序，不断重复1-2-3-4的步骤，直到数列中，所有的数据都被处理。

11.尝试使用HuffmanCode对数据进行压缩
   思路:
       -> 1) 首先将需要压缩的数据进行字符频度统计 --> HashSet存储   HashMap?
       -> 2) 将统计完毕的结点载入排序中,构建HuffmanTree
       -> 3) 遍历HuffmanTree,将每个字符对应的编码存储     ※???
       -> 4) 遍历需要压缩的数据，将原数据进行编码
       -> 5) 将每个结点中存储的数据载入文件之中,便于解码
   附:这里实在没有想到如何处理HuffmanCode生成问题,老韩给出的解题思路(递归形式)确实牛





















