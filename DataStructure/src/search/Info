查找算法

常见查找算法:
1) 顺序(线性)查找
2) 二分查找/折半查找
3) 插值查找
4) 斐波那契查找

1.这里不对线性查找方式进行实现...

2.二分查找方式:
    1) 要求查询的序列为有序序列
    2) 如何实现多重查找? -> 记录查询到的元素的位置，从下一个元素开始继续寻找
        -> 将返回值一开始设为-1,查询过程之中,若查询到对应元素，则返回坐标值
        -> 若index不为-1，则存在该元素
        -> 从index+1 ~ array.length-1继续进行查找 (别忘了初始化index 为-1  -> 先将index值存储)

3.插值查找算法    -> BinarySearchPlus
    1) 二分查找方式仍存在对于边界的值的查询需要多次寻找的情况
    2) 这里使用一种更加优良的方案进行处理
       int mid = (left+right)/2 = left + (right-left)/2;
     =>int mid = left + (key-array[left])/(array[right]-array[left])*(right-left)
附: 注意，此种方法下，temp(key)的值不可以太离谱了 晕
    ->  进一步处理

4.斐波那契查找方法
    1) 与二分查找算法及插值法类型，只不过mid的值修改为黄金分割点附近
附: 大体思路是首先生成一个斐波那契数列,该数列的长度需要给定(用于生成近似0.618的数);
    然后寻找到一个合适的斐波那契点,使得(high-low) = f[k]-1 (当然也存在不合适的地方,这里使用最高位元素进行填充);
    接下来将f[k-1] = f[k-2] + f[k-3] - 1用于对序列进行拆分;
    mid = low + f[k-1] - 1;         //这里参考PPT上的图解会更好
    注:mid将原序列分为f[k-2] + f[k-3]两部分,前一部分为f[k-2],数值更长;
       因此在前序序列查询的时候，将f[k-1]-1进行拆分,后续序列为将f[k-2]-1进行拆分 -> k--;k-=2;